<!doctype html>
<html>
<head>
  <title>Introducing Modular CSS With BEM</title>
  <link rel="stylesheet" href="/css/reveal.css" />
  <link rel="stylesheet" href="/css/theme/night.css" />
  <link rel="stylesheet" href="/css/rainbow.css" />
</head>
<body>
  <div class="reveal">
    <div class="slides">
      <!-- Intro Slide -->
      <section>
        <h1>Introducing Modular CSS with BEM</h1>
        <p>- Caitlin</p>
      </section>
      <!-- CSS Overview -->
      <section>
        <h2>Quick overview of CSS</h2>
        <p class="fragment"><strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets</p>
        <aside class="notes">
          <p>Stylesheets are used to style your website. The CSS tells the browser what to make things look like: whether something has black text or white, where to position it, etc.</p>
        </aside>
      </section>
      <section>
        <h2>The Cascade</h2>
        <p>Two things in CSS help determine what an element looks like.</p>
        <ol>
          <li>Specificity</li>
          <li>Where the style rule lives in the stylesheet file</li>
        </ol>
        <div>
        <code>
          <p>a { color: red; }</p>
          <p>a { color: blue; }</p>
          &lt;a href="#"&gt;This link will be blue&lt;/a&gt;
        </code>
      </div>
        <aside class="notes">
          <p>Cascading = how stylesheets work. When more than one stylesheet rule can apply to a particular element in the html, the cascade determines which style is going to win.</p>
          <p>Specificity is a measurement of the strength of a particular style rule. More on that in a moment.</p>
          <p>Position matters. Given two rules that have an equal specificity, the one further down the css file will override the one that is higher.</p>
        </aside>
      </section>
      <section>
        <h2>Specificity</h2>
        <a href="https://stuffandnonsense.co.uk/archives/images/specificitywars-05v2.jpg" target="_blank"><img src="/images/specificitywars.jpg" style="max-width: 50%" /></a>
        <p><small>Source: https://stuffandnonsense.co.uk/archives/images/specificitywars-05v2.jpg</small></p>
        <aside class="notes">
          <p>Element selectors are the weakest, followed by class selectors and then finally ID selectors.</p>
          <p>IDs can be very difficult to override - it's generally a rule in the community to not use IDs for styling, as that can lead to css that is difficult to update and maintain.</p>
          <p>Selectors that are combined are more and more powerful, as you can see in the chart.</p>
        </aside>
      </section>
      <section>

        <section>
          <h2>Trouble in (CSS) Paradise</h2>
        </section>
        <section>
          <h3>!important</h3>
          <div>
            <pre><code>#creature.equine.unicorn .body mane hair { color: blue; }</code></pre>
          </div>
          <div class="fragment">
            Red hair for all? OK:
            <pre><code>#creature hair { color: red !important; }</code></pre>
          </div>
          <div class="fragment">
            Oh, but horses need green hair:
            <pre><code>#creature.horse hair { color: green !important; }</code></pre>
          </div>
          <div class="fragment">
            ... and so on.
          </div>
          <aside class="notes">
            <p>It can be tempting to override a complex selector with !important. !important will override pretty much anything. The problem is a single !important may lead to others.</p>
            <ol>
              <li>There's a complex selector. Your boss says "Hey, animals all need red hair." So you just use !important. Nice and easy, done!</li>
              <li>A week later the client says "We love the red hair, but horses need green hair." You have to raise the specificity in order to override that !important.</li>
              <li>What if later on, horses of a certain breed need black hair? And so on, and so forth. A single !important breeds more down the line.</li>
            </ol>
          </aside>
        </section>
        <section>
          <h3>Long nested selectors</h3>

          <div class="clearfix group">
            <div style="width: 60%; float: left; ">
              <p><strong>HTML</strong></p>
              <pre style="width: 95%; margin:0;"><code data-trim>
<creature id="horse" class="horse equine">
  <mane></mane>
</creature>

<creature id="unicorn" class="unicorn equine">
  <mane></mane>
</creature>
                </code></pre>
            </div>
            <div style="width: 40%; float: left;">
              <p><strong>CSS</strong></p>
              <pre style="width: 95%;"><code data-trim>
// relatively simple selector
.horse mane {
  color: brown;
}

// complex selector
creature#unicorn.equine.unicorn mane {
  color: black;
}
                </code></pre>
            </div>
          </div>
          <p style="clear:both;" class="fragment">The client says hey, all horses and unicorns need white manes.</p>
          <pre class="fragment"><code data-trim data-noescape>
.equine mane {
  color: white <span class="fragment">!important;</span> <span class="fragment">:(</span>
}
            </code></pre>
          <aside class="notes">
            <p>For example, you're working this website, and the client says, "Hey, all equine animals need white manes."</p>
            <p>Will the .equine mane { } selector work if we place it after the other rules? Well, it will override the horse rule, but not the other one.</p>
            <p>So in this case you'd be forced to use important, rewrite the old class, or write another equally strong selector to override everything.</p>
            <p>This can lead to difficult-to-maintain CSS that just gets more and more bloated as time goes on.</p>
            <p>That selector is big and clearly unnecessary, but it's actually deceptively easy to write something very similar to it with less and sass. Because you can nest selectors, you don't always have a lot of awareness for how many levels deep you are at any given time.</p>
          </aside>
        </section>
        <section>
          <h3>Inline styles</h3>
            <pre><code data-trim>
              <mane style="color: red;"></mane>
            </code></pre>
            <p>These can only be overwritten with !important</p>
            <aside class="notes">
              <p>Inline styles can be really tempting because they are so easy to add in. A single file gets changed and you're good to go!</p>
              <p>The problem is that inline styles cannot easily be attributed to other items. So if you have 85 unicorns on your website, you would need to put inline styles on each one.</p>
              <p>Inline styles can only be overwritten with !important, which is always a hassle but definitely doesn't play nice with responsive websites. It leads to !important hell in media queries.</p>
            </aside>
        </section>
      </section>
      <section>
        <h2>So how do we fix it?</h2>
      </section>
      <section>
        <h2>BEM to the rescue.</h2>
        <p class="fragment"><strong>B</strong>lock</p>
        <p class="fragment"><strong>E</strong>lement</p>
        <p class="fragment"><strong>M</strong>odifier</p>
        <aside class="notes">
          <p>Block - a standalone entity that is meaningful on its own.<br/>
            e.g. header, menu, form input<br/>
            non-html: unicorn</p>
          <p>Element - Parts of a block that have no standalone meaning. They are intrinsically tied to the block in which they reside.<br/>
            e.g. menu item, list item<br/>
            non-html: unicorn's horn, mane, coat</p>
          <p>Modifier - Flags on blocks or elements. They change appearance or behavior.<br/>
            e.g. disabled, checked, selected<br/>
            non-html: old, pregnant, hungry</p>
        </aside>
      </section>
      <section>
        <h2>Why use BEM?</h2>
        <ol>
          <li>Modular</li>
          <li>Reusable</li>
          <li>Tied to structure</li>
        </ol>
        <aside class="notes">
          <ol>
            <li>Modular
              <ul>
                <li>you won't get problems from cascading because your blocks generally do not rely on other elements on the page.</li>
                <li>It would fit in very nicely with atomic design principles (Blocks = molecules and so on)</li>
              </ul>
            </li>
            <li>Reusable
              <ul>
                <li>you should run into less instances of repeated code because you can easily reuse the same styles in multiple places.</li>
                <li>you can more easily move css from one project to another!</li>
              </ul>
            </li>
            <li>Structure
              <ul>
                <li>with BEM naming, you can understand some things about the html code without even seeing the html code e.g. you will always know that menu__item is an item that lives inside a menu.</li>
                <li>because of this, you are allowed greater confidence in making css changes. It's common to never delete CSS because you have no idea what items might be using that class and whether you are going to break some obscure part of your site. With BEM naming, you should be able to delete or rename CSS with higher levels of confidence.</li>
              </ul>
            </li>
          </ol>
        </aside>
      </section>
    </div>
  </div>
  <!--

    So how does it work?
    - Let's say you have an element that will be living on the homepage with links to news articles, videos, etc. Let's name it .news-showcase

    <ul class="news-showcase">
      ...
    </ul>

    Now let's add some showcase items.

    <ul class="news-showcase">
      <li>
        ...
      </li>
      <li>
        ...
      </li>
      <li>
        ...
      </li>
    </ul>

    We _could_ style this by just doing css like so:
      .news-showcase li { }
    ... but this assumes that it will always be an li, which is not necessarily the case. .news-showcase doesn't have to be a ul (unordered list).
    ... this also has higher specificity. if we EVER want to override any of the styles, we will have to either repeat the full rule and have it lower on the page, or add more specificity.

    So what would be better? Let's use BEM.
    .news-showcase__item { }  // you can tell just by looking at this that it is a child of news-showcase. You don't even need to see the HTML to know that.

    <ul class="news-showcase">
      <li class="news-showcase__item">
        ...
      </li>
      <li class="news-showcase__item">
        ...
      </li>
      <li class="news-showcase__item">
        ...
      </li>
    </ul>

    Okay let's add some more. I'm going to reduce this to a single LI for simplicity.

    <ul class="news-showcase">
      <li class="news-showcase__item">
        <h3>Lorem ipsum</h3>
        <a href="#">Dolor Sit Amet</a>
      </li>
    </ul>

    The old way you might have done:
    .news-showcase h3, or possibly even .news-showcase li h3.
    Why don't you want to do that? Well, what if later you want to reuse this element somewhere else, but h3 doesn't make sense anymore? What if it's an h2 instead?
    Styling headings (h1, h2, h3, h4, h5, h6) can often bite you later because we just aren't consistent with how headings are displayed across a website. That isn't a bad thing, it's just a fact. Different sections may require different styles for the same level of heading.

    So let's BEM this.
    <ul class="news-showcase">
      <li class="news-showcase__item">
        <h3 class="news-showcase__heading">Lorem ipsum</h3>
        <a href="#" class="btn">Dolor Sit Amet</a>
      </li>
    </ul>

    Note that the heading is NOT news-showcase__item__heading. We still just consider it a child of news-showcase. It's pretty unlikely that we'd need to style the heading of news-showcase__item from news-showcase. This helps prevent BEM classes from getting way too long, and also keeps them reuseable.
    Also notice that it is NOT news-showcase__btn. Button styles are often reuseable across a whole website, so it wouldn't make sense to specifically name this as a child of news-showcase. It's merely a button, a fully standalone "block" element, that happens to live inside news-showcase.
      - Why isn't __heading the same? Again, headings are more difficult to blanket style across a whole site. The styles we're using for the heading are specific to this section and not likely to be reused elsewhere.

    Okay, nearly done. What if we want this button to be special somehow? What if all the other buttons are transparent with a border around them, but we want this one to be a solid color?

    <a href="#" class="btn btn--solid">Dolor Sit Amet</a>

    .btn { border: 1px solid #000; color: #000; background: transparent; padding: 10px 20px; font-size: 18px; display: inline-block; }
    .btn--solid { border: none; background: #fff; }

    We can add a modifier class, btn--solid. It's still a .btn, but has a modifier of .btn--solid. It will inherit all of the styles of .btn, and then will override with any styles included in .btn--solid.
    So it will override the border and background color, but will inherit the text color, padding, font size, and display attribute.


    POTENTIAL PITFALLS
    Modifiers are great - just make sure you aren't including things as the default style that don't need to be. For example, if you find yourself constantly overriding the border style on a button, maybe the border should not be a default. You could remove that from .btn and then have btn--has-border.
    When naming new styles, try to think about what a block is. If the item you are styling can be standalone and doesn't rely on its container, don't name it like an element.



  REFERENCES:
  http://getbem.com/introduction/
  -->
  <script src="/js/head.min.js"></script>
  <script src="/js/reveal.js"></script>
  <script>
    Reveal.initialize({
      dependencies: [
        { src: '/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
      ],
      showNotes: true,
      history: true
    });
  </script>
</body>
</html>
